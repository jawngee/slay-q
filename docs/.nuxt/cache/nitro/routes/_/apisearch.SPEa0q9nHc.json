{"expires":1705307741128,"value":{"code":200,"headers":{"etag":"W/\"5DJ4c2h9cQ\"","last-modified":"Mon, 15 Jan 2024 08:35:40 GMT"},"body":[{"id":"content:0.index.md","path":"/","dir":"","title":"SlayQ - Open Source Background Workflow Scheduler","description":"","keywords":[],"body":"    Open source background workflow scheduler built with Graphile Worker.   Slay  Q  is an open source background job and workflow scheduler for fullstack TypeScript apps.  Easily add complex background\nprocessing and cronjobs to you app without the expense of an external SaaS.     Complex Workflows    Write multistep background jobs  with complex workflows.    Cron Jobs   Write   jobs that run on a schedule  using familiar crontab syntax.    Supabase Support   Direct support for dispatching jobs through Supabase via   supabase-js .    Migrate From/To Inngest   Mostly Inngest compatible jobs makes porting to or from Inngest easy and straight forward.    Easy Deploy and Integration   Easy to work into existing apps.  Server is a single app that is easily deployed via docker.    Free   No per task or per step charges.  Easily dispatch 100K events on a low cost droplet or cloud server."},{"id":"content:1.guide:0.getting-started.md","path":"/guide/getting-started","dir":"guide","title":"Getting Started","description":"Using SlayQ requires a few steps:","keywords":["Run the Example App","How the Example App Works"],"body":"  Getting Started  Using SlayQ requires a few steps:   Install the slay-q client into your Nuxt or Next (or SvelteKit or whatever) app  Run the SlayQ event server  Optionally run the SlayQ HTTP RPC ingest server  Run the Example App  We provide a sample Nuxt app with SlayQ integrated already so that you can see how the integration works and how jobs are\ndefined or written:      npx   giget@latest   gh:SlayPics/SlayUtils/examples/nuxt-example   slayq-nuxt-example   --install\n   cd   slayq-nuxt-example\n   pnpm   install\n   cp   example.env   .env\n   docker   compose   up   -d\n   pnpm   run   dev\n     npx   giget@latest   gh:SlayPics/SlayUtils/examples/nuxt-example   slayq-nuxt-example   --install\n   cd   slayq-nuxt-example\n   npm   install\n   cp   example.env   .env\n   docker   compose   up   -d\n   npm   run   dev\n     npx   giget@latest   gh:SlayPics/SlayUtils/examples/nuxt-example   slayq-nuxt-example   --install\n   cd   slayq-nuxt-example\n   yarn   install\n   cp   example.env   .env\n   docker   compose   up   -d\n   yarn   dev\n  Once installed, navigate to   http://localhost:3000/ .  The UI here is just a mechanism for triggering\nevents, it won't provide any feedback as to the result of the events running.  You should watch the console to see that aspect in\naction.  How the Example App Works  The key directories of the example app are:    server/slay-q  - This directory contains the example functions and the SlayQ client export to be used by the rest of the application.   server/api/slay-q  - This is the receiving endpoint that receives events from SlayQ server (a wrapper around Graphis Worker).  Any application wanting to integrate SlayQ will have to implement something similar to the above.  You'll need to define functions,\ncreate a SlayQ client and register those functions with the client.  The other aspect of the example app is a   docker-compose.yml  file that loads three components that work in tandem to store events\nand dispatch them to your application:    Postgresql Server  - The datastore for events.   HTTP RPC Ingest Server  - An HTTP interface your application would use to trigger jobs and otherwise interface with the system.   Slay Q Server  - Dispatches jobs from the database and sends them to your app.  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"},{"id":"content:1.guide:1.how-it-works.md","path":"/guide/how-it-works","dir":"guide","title":"How It Works","description":"Put in the most simple terms: at certain points in your application something will happen that triggers an event you want to\nprocess in the background, for example a file upload.  When this happens, your app saves the event to your supabase/postgres\ndatabase.  The SlayQ server picks up the event and sends it to your application for processing.","keywords":[],"body":"  How It Works  Put in the most simple terms: at certain points in your application something will happen that triggers an event you want to\nprocess in the background, for example a file upload.  When this happens, your app saves the event to your supabase/postgres\ndatabase.  The SlayQ server picks up the event and sends it to your application for processing.  Of course, it's a bit more complicated than that, but that's the general gist.  You have control over concurrency and can create\nmulti-step background tasks that have very complicated workflows.  You can schedule these events to run well in the future or you\ncan create jobs that run on a schedule.  SlayQ is broken into two components: the SlayQ client and the SlayQ server.  There is an optional third component called the SlayQ\nIngest server which acts as an HTTP RPC interface to the server components.  At a minimum though, you'll need to include the client\nin your application and run the server elsewhere.  "},{"id":"content:1.guide:2.installing.md","path":"/guide/installing","dir":"guide","title":"Using In Your App","description":"","keywords":["Installing Into Your App","Running the Dev Server","Next Steps"],"body":"  Using In Your App  Installing Into Your App      npm   install   @slaypics/slay-q\n     yarn   install   @slaypics/slay-q\n     pnpm   install   @slaypics/slay-q\n  Additionally, you'll need to select a driver package to connect to your database:     @slay-pics/slay-q-supabase  - Supabase driver that uses   @supabase/supabase-js  to connect to supabase.    @slay-pics/slay-q-postgres  - Driver that talks directly to Postgres via   pg  package.    @slay-pics/slay-q-rpc  - Driver that talks to a    slay-q-ingest  instance.  The Slay Q ingest is an HTTP RPC server.  See the nuxt example app for an example of its use.  If the bulk of your app is using   supabase-js  to access Supabase then choose the Supabase driver.  Otherwise, if you are using\nsomething like   pg ,   drizzle  or   knex  then use the Postgres driver.  If you'd like to futureproof your app a little, using the RPC driver but know that you'll have to deploy the RPC Ingest Server\nalongside the SlayQ server.  It deploys easily on Vercel and other serverless providers.  Environment Variables  You can configure the driver by passing in options to the constructor, or alternatively you can specify the following environment variables,  For the supabase driver:    SUPABASE_URL  - URL to your supabase instance   SUPABASE-SERVICE-KEY  - Service key for your supabase instance  For the postgres driver:    DATABASE_URL  - The database connection string url  For the Ingest RPC driver:    SLAY_Q_WORKER_SECRET  - Shared secret used to validate RPC requests   SLAY_Q_INGEST_ENDPOINT  - URL to the slay-q ingest endpoint  Running the Dev Server  To get started quickly, you can run the dev server locally:      npx   giget@latest   gh:SlayPics/SlayUtils/docker   slayq-docker\n   cd   slayq-docker\n   docker   compose   up   -d\n  This will launch three containers: a postgres instance, the Slay Ingest RPC server and the SlayQ server.  You should configure\nyour client (  read more ) with the RPC driver using the following environment variables and values:      SLAY_Q_WORKER_SECRET  =  G,4DgB  $  .  ?>  X]\"w}w1745Xq2nKoM4BG74\n   SLAY_Q_INGEST_ENDPOINT=http://localhost:3012\n  Next Steps  Once you've installed the packages and have the dev server running:    Write some functions   Configure the client  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"},{"id":"content:1.guide:3.functions.md","path":"/guide/functions","dir":"guide","title":"Functions","description":"","keywords":["Writing Functions","Function metadata","Step Types"],"body":"  Functions  Writing Functions  The key unit of Slay Q is an event which is represented as a function.  Each event/function is made up of individual steps.  When\nSlay Q executes a function it caches the output of each step so that if one should fail, and the function is retried, the steps\nbefore the failure don't need to be re-run.  To create a function, simply call the   defineSlayQFunction  function and specify some metadata about the function and the function's\nbody.  Here's an example:     import   { z }   from   \"zod\"  ;\n   import   { defineSlayQFunction }   from   \"@slay-pics/slay-q\"  ;\n   \n   // Each function has data that can be passed to it,\n   // this is the schema for that data.\n   export   const   TextFunctionEvent   =   z.  object  ({\n     testString: z.  string  (),\n   });\n   \n   // The test event\n   export   const   testEvent   =   defineSlayQFunction  (\n     {\n       event:   \"test/event\"  ,\n       schema: TextFunctionEvent,\n     },\n     async   ({   event  ,   data  ,   step  ,   retry   })   =>   {\n       console.  log  (  \"retry\"  , retry);\n   \n       const   val   =   await   step.  run  (  \"first-step\"  ,   async   ()   =>   {\n         console.  log  (  \"first step\"  );\n         return   \"hello\"  ;\n       });\n   \n       const   val2   =   await   step.  run  (  \"second-step\"  ,   async   ()   =>   {\n         console.  log  (  \"second step\"  );\n         return   \"world\"  ;\n       });\n   \n       const   val3   =   await   step.  run  (  \"third-step\"  ,   async   ()   =>   {\n         if   (retry   ===   1  ) {\n           throw   new   Error  (  \"Yoinks.\"  );\n         }\n   \n         return   data.testString;\n       });\n   \n       console.  log  (  `${  val  } ${  val2  } ${  val3  }`  );\n     }\n   );\n  In this example the function is composed of three different steps.  On the first run of the function step 3 will explode.  However,\nSlay Q will cache the output of the previous two steps so that when it requeues the event to run again, those steps won't run as\ntheir values have already been computed.  Each step must have a unique name, Slay Q will refuse to run it if they don't.  If you are running steps in a for-loop, for example,\nyou'll need to make sure the step name is different on each iteration by appending a counter to the name.  Function metadata  When creating a function, you will need to specify some metadata about it.   event  This is the name of the event that is triggering the function.  This is completely arbitrary but it must be unique amongst all\nof your functions.  We use the form   group/subgroup/verb  such as   media/avatar/process  but it's completely up to you.   schema  This is a   zod  schema for the data that is being passed to the function.  If you don't have any data, you can use the   SlayQEmptyEvent \nschema.  This schema is used to give runtime checking when receiving and event, and is also used to infer types in the type system.   queue?  This is the name of the queue that processes these events.  When you run   slay-q-server  you define queues and their corresponding\nconcurrencies in a   slay-config.json  file.  This name should match up to one of the names specified in the   queue  section of\nthat config file.  The default value for this is   general .  If you don't specify a queue on the function and you haven't specified\na queue named   general  in your server config these events will end up in limbo.   retries?  This is the number of times to retry this function before giving up.  The default is 25.   priority?  This is the priority of the function.  This priority is reversed so that a priority of 0 is the highest.   cron?  Specifying this value will run the function on the specified schedule.  This is a standard   crontab  string.  You can prefix this string with   TZ=<Timezone string>  to force a timezone.  For example, to make sure a function runs every\nday at 3am in Singapore, you'd specify the cron as   TZ=Asia/Singapore 0 3 * * * .   Note that crontab functions cannot have data schemas, so use the   SlayQEmptyEvent  schema.  Otherwise, it will error out every time.   cancelOn?  This is a list of conditions that can cancel this event.     export   const   CancelOnTestEvent   =   z.  object  ({\n     someDataId: z.  string  (),\n   });\n   \n   export   const   cancelOnTest   =   defineSlayQFunction  ({\n       event:   \"testing/cancel-on-test\"  ,\n       schema: CancelOnTestEvent,\n       cancelOn: [{\n         event:   \"testing/cancel-on-test\"  ,\n         match:   \"someDataId\"  ,\n       }],\n     },\n     async   ({   event  ,   data  ,   step  ,   retry   })   =>   {\n       console.  log  (  \"cancel on test\"  , retry);\n       step.  sleep  (  'so-tired'  ,   '8h'  );\n       console.  log  (  'and we are back'  );\n     }\n   );\n  In this example, this function can cancel itself.  You'll notice that it sleeps for 8 hours in the middle of the function.  Should\nwhatever system generate another event with the same matching   someDataId  then that will cancel the previous sleeping function\nwith that same   someDataId  value.   waitsOn?  and   invokes?  See the   step.waitForEvent  and   step.invoke  below for more info.  Step Types  Each function workflow is composed of steps and there are a variety of types of steps you can use to build your workflows.  These are mostly the same as Inngest, but there are some differences.  run(name, handler)  This step runs a chunk of code (see above for an example).  sleep(name, duration)  This step will sleep the function for a given duration.  The duration can be specified using strings like   5m ,    3 years , etc.\nSee   ms  for more examples.     export   const   someEvent   =   defineSlayQFunction  (\n     {\n       event:   \"test/event\"  ,\n       schema: SlayQEmptyEvent,\n     },\n     async   ({   event  ,   data  ,   step  ,   retry   })   =>   {\n       const   val   =   await   step.  run  (  \"first-step\"  ,   async   ()   =>   {\n         console.  log  (  \"first step\"  );\n         return   \"hello\"  ;\n       });\n   \n       await   step.  sleep  (  'hush-baby'  ,   '1 year'  );\n   \n       const   val2   =   await   step.  run  (  \"second-step\"  ,   async   ()   =>   {\n         console.  log  (  \"second step\"  );\n         return   \"world\"  ;\n       });\n   \n       console.  log  (  `${  val  } ${  val2  }`  );\n     }\n   );\n  sleepUntil(name, date)  This step will sleep the function until a specific date.  The date can be a javascript Date object or a string.     export   const   someEvent   =   defineSlayQFunction  (\n     {\n       event:   \"test/event\"  ,\n       schema: SlayQEmptyEvent,\n     },\n     async   ({   event  ,   data  ,   step  ,   retry   })   =>   {\n       const   val   =   await   step.  run  (  \"first-step\"  ,   async   ()   =>   {\n         console.  log  (  \"first step\"  );\n         return   \"hello\"  ;\n       });\n   \n       await   step.  sleepUntil  (  'hang-on'  ,   '1/1/2025'  );\n   \n       const   val2   =   await   step.  run  (  \"second-step\"  ,   async   ()   =>   {\n         console.  log  (  \"second step\"  );\n         return   \"world\"  ;\n       });\n   \n       console.  log  (  `${  val  } ${  val2  }`  );\n     }\n   );\n  waitForEvent(name, event, timeout)  This step will pause execution until a matching event has been run.  This functions works the same as Inngest, but you have to do\nan extra step.     export   const   waitsOnTestEvent   =   defineSlayQFunction  (\n     {\n       event:   \"testing/waits-on-test\"  ,\n       schema: WaitsOnTestEvent,\n       waitsOn: [{ event:   \"testing/waited-for-test\"  , match:   \"waitingForId\"   }],\n     },\n     async   ({   event  ,   data  ,   step   })   =>   {\n       const   step1val   =   await   step.  run  (  \"step-1-val\"  ,   async   ()   =>   12  );\n       const   step2val   =   await   step.  run  (  \"step-2-val\"  ,   async   ()   =>   \"cool\"  );\n   \n       console.  log  (  \"waiting ...\"  );\n       const   result   =   await   step.  waitForEvent  (  \"waiting-for-something\"  ,   \"testing/waited-for-test\"  ,   \"2m\"  );\n       if   (  !  result) {\n         console.  log  (  \"event did not fire.\"  );\n       }   else   {\n         console.  log  (  \"event did fire.\"  );\n       }\n   \n       console.  log  (  \"done waiting ...\"  );\n     }\n   );\n  The difference here, from Inngest, is that you need to declare that the function will wait on another one at some point in the function's\n  waitsOn  metadata.  Also, you can only match on a single property of the event's data.  Slay Q doesn't support CEL expressions like\nInngest does.  invoke(name, event, data,   timeout )  The step will invoke another event and wait for it to return a result, optionally waiting for the specified   timeout  period.  This\none is super juicy.     export   const   testCallerEvent   =   defineSlayQFunction  (\n     {\n       event:   \"test/caller\"  ,\n       schema: SlayQEmptyEvent,\n       invokes: [  'test/callee'  ]\n     },\n     async   ({   event  ,   data  ,   step  ,   retry   })   =>   {\n       const   val   =   await   step.  run  (  \"first-step\"  ,   async   ()   =>   {\n         console.  log  (  \"first step\"  );\n         return   \"hello\"  ;\n       });\n   \n       const   val2   =   await   step.  invoke  (  'yo'  ,   'test/callee'  , {},   '5m'  );\n       if   (  !  val2) {\n         console.  warn  (  'nobody home'  );\n         return  ;\n       }\n   \n       console.  log  (  `${  val  } ${  val2  }`  );\n     }\n   );\n   \n   export   const   testCalleeEvent   =   defineSlayQFunction  (\n     {\n       event:   \"test/callee\"  ,\n       schema: SlayQEmptyEvent,\n     },\n     async   ({   event  ,   data  ,   step  ,   retry   })   =>   {\n       return   'world'  ;\n     }\n   );\n  In this example, when the   testCallerEvent  is invoked, Slay Q will dispatch an event to the   testCalleeEvent  and then return\nthat response.  Note that   testCalleeEvent  is not invoked directly, it is called just like any other event would be called.  So\nif you are running in a serverless environment like Vercel or AWS Lambda then it's possible   testCalleeEvent  is running on a\ntotally different server.   Like   waitForEvent , you need to mark that this function will invoke another by specifying which event or events it invokes in\nthe function's   invokes  metadata.  sendEvent(name, event) / sendEvents(name, events)  This will simply dispatch another event (or multiple events) and continue processing the function.   This is another difference with Inngest.  With Inngest, you can send a single event or multiple events with the same call.  With\nSlayQ you must call   sendEvent  for a single event or   sendEvents  for multiple.  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"},{"id":"content:1.guide:4.client.md","path":"/guide/client","dir":"guide","title":"SlayQ Client","description":"","keywords":["Creating the Client","Dispatch Events","Receiving Events"],"body":"  SlayQ Client  Creating the Client  In order to dispatch or receive events in whatever stack you are working with, you'll need to create a client.  Here's an example:     import   { SlayQClient }   from   \"@slay-pics/slay-q\"  ;\n   import   { SlayQSupabaseDriver }   from   \"@slay-pics/slay-q-supabase\"  ;\n   \n   import   { sleepTestEvent,   type   SleepTestEvent }   from   \"~/server/slay-q/testing/sleep-test\"  ;\n   import   { cronTestEvent,   type   CronTestEvent }   from   \"~/server/slay-q/testing/cron-test\"  ;\n   import   { cancelOnTest,   type   CancelOnTestEvent }   from   \"~/server/slay-q/testing/cancel-on-test\"  ;\n   \n   export   type   TestingEvents   =   {\n     \"testing/sleep-test\"  :   z  .  infer  <  typeof   SleepTestEvent>;\n     \"testing/cron-test\"  :   z  .  infer  <  typeof   CronTestEvent>;\n     \"testing/cancel-on-test\"  :   z  .  infer  <  typeof   CancelOnTestEvent>;\n   };\n   \n   export   const   TestingFunctions   =   [\n     sleepTestEvent,\n     cronTestEvent,\n     cancelOnTest,\n   ];\n   \n   export   const   defaultSlayQClient   =   new   SlayQClient  <  TestingEvents  >({\n     driver:   new   SlayQSupabaseDriver  (),\n     endpoint:   \"http://localhost/api/slay-q\"  ,\n     functions: [\n       ...  TestingFunctions,\n     ],\n   });\n  There's a bit to unpack here.  First we are creating a   TestingEvents  type that maps an event to the event's data type (inferred from the event's data's schema).\nThis type is then passed to the SlayQClient so that any calls to   sendEvent  are typed.  Second thing we are doing is creating a   const  called   Testing Functions  that is just an array of all of our testing functions.  It\nseems silly to do it for just 3 functions, but when this gets larger and you're pulling in functions for different parts of your app,\nyou'll want to keep this as organized and neat as possible.  We have 180+ functions in use on Slay.  The   endpoint  is where   slay-q-server  can callback to when it has an event for your app to process.  Obviously this should be\nspecified with configuration or environment variables.  The   driver  is the interface with the database that the client will use.  Slay Q provides three base packages with different drivers:     @slay-pics/slay-q-supabase  - Supabase driver that uses   @supabase/supabase-js  to connect to supabase.    @slay-pics/slay-q-postgres  - Driver that talks directly to Postgres via   pg  package.    @slay-pics/slay-q-rpc  - Driver that talks to a    slay-q-ingest  instance.  The Slay Q ingest is an HTTP RPC server.  See the nuxt example app for an example of its use.  Dispatch Events  Once you've created the client, dispatching events is easy:     await   defaultSlayQClient.  sendEvent  (  \"products/video-product/unlocked\"  , {\n     videoProductId: videoProduct.id,\n     profileId: profile.id,\n     userId: profile.user_id,\n   });\n  In this example, we're dispatching an unlocked event for a video product with the associated data needed for the event.  Receiving Events  This is where it will get trickier because this part is dependent entirely on whatever stack or backend you are using.  For us,\nthat is   Nuxt .  We create a nitrojs handler at   /api/slay-q/index.post.ts  that looks like:     import   { useValidatedBody }   from   \"h3-zod\"  ;\n   import   { createError, H3Event, sendError }   from   \"h3\"  ;\n   import   { SlayQReceiveEventPayloadSchema }   from   \"@slay-pics/slay-q\"  ;\n   import   { defaultSlayQClient }   from   \"~/lib/slay-q/default-slay-q-client\"  ;\n   \n   export   default   defineEventHandler  (  async   event   =>   {\n     const   sig   =   getHeader  (event,   \"X-SlayQ-Signature\"  );\n     if   (  !  sig) {\n       sendError  (event,   createError  ({ statusCode:   400  , statusMessage:   'Invalid signature'   }));\n       return  ;\n     }\n   \n     const   body   =   await   useValidatedBody  (event, SlayQReceiveEventPayloadSchema);\n   \n     await   defaultSlayQClient.  receiveEvent  (sig, body);\n   \n     return   {\n       status:   \"ok\"  ,\n     };\n   });\n  First we get the   X-SlayQ-Signature  header which contains the signature of the request.  Note that you will need to have the\nenvironment variable   SLAY_Q_WORKER_SECRET  defined in your   .env  or wherever you are specifying environment variables.  We then fetch the body of the request (as a parsed JSON object) with   useValidatedBody .  We've passed in the\n  SlayQReceiveEventPayloadSchema  schema to validate the payload against.  We then call the   receiveEvent  method on the SlayQClient instance which handles the rest.  This should be pretty easy to adapt other frameworks.  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"},{"id":"content:1.guide:5.server.md","path":"/guide/server","dir":"guide","title":"SlayQ Server","description":"The SlayQ server is a wrapper around Graphile Worker.  It must be deployed to a server and run 24/7.  You\ncannot deploy it to a serverless environment.","keywords":["Configuration","Database Migrations","Run via Docker","Run via Command Line"],"body":"  SlayQ Server  The SlayQ server is a wrapper around   Graphile Worker .  It must be deployed to a server and run 24/7.  You\ncannot deploy it to a serverless environment.  Configuration  To run the SlayQ server you must first configure your environment and create a   slay-config.json  configuration file that contains\ninformation about your queues.  Environment Variables  SlayQ server expects the following environment variables to be defined:    SLAY_Q_DATABASE_URL  - The connection string url for your postgres database.   SLAY_Q_SECRET  - The secret used to sign events posted to your app's slay-q receiver endpoint.   SLAY_Q_CRON_URL  - The URL to your slay-q receiver endpoint that will receive cron events.  If you are running in a docker\nimage and attempting to access a dev server running on localhost, you should use   http://host.docker.internal:3000/  instead of\n  http://localhost:3000 .  Queue Configuration  You must create a file named   slay-config.json  and pass it as an argument to the SlayQ server.  The configuration file looks like:      {\n     \"queues\"  : {\n       \"mail\"  : {\n         \"concurrency\"  :   4\n       },\n       \"messaging\"  : {\n         \"concurrency\"  :   6  ,\n         \"alias\"  : [\n           \"dispatch\"  ,\n           \"ready\"\n         ]\n       },\n       \"interactions\"  : {\n         \"concurrency\"  :   1  ,\n         \"alias\"  : [\n           \"reconcile\"  ,\n           \"discord\"\n         ]\n       },\n       \"housekeeping\"  : {\n         \"concurrency\"  :   2\n       },\n       \"profile\"  : {\n         \"concurrency\"  :   8\n       },\n       \"general\"  : {\n         \"concurrency\"  :   10\n       }\n     }\n   }\n  We are essentially defining a variety of queues and their level of concurrency (the number of tasks that can run at once in the queue).\nAdditionally, we are specifying aliases for these queues.  These aliases are only provided to help keep things organized on the client\nside of things.  For example, the messaging queue has the aliases \"dispatch\" and \"ready\".  These are just additional identifiers, it\ndoesn't mean we are defining three additional queues with the same properties.  Therefore, the concurrency will be shared with aliases.  Database Migrations  The first time you run the server, two migrations will be run:   A schema and related tables called   graphile_worker  will be created.  This schema is required for Graphile Worker to function.  A second schema and related tables/function called   slayq  will be created.  This contains all the tables and functions SlayQ\nneeds to do its housekeeping.  Additionally, a few functions will be created in the   public  schema.  This is necessary for Supabase as you cannot access other\nschemas with their js libs.  Run via Docker  The recommended approach is using docker via our   slaypics/slay-q-server  docker image.      version  :   '3.1'\n   services  :\n     slay_q_server  :\n       image  :   slaypics/slay-q-server\n       restart  :   always\n       environment  :\n         -   SLAY_Q_DATABASE_URL=postgresql://postgres:postgres@slay_q_postgres:5432/postgres\n         -   SLAY_Q_SECRET=G,4DgB$.?>X]\"w}w1745Xq2nKoM4BG74\n         -   SLAY_Q_CRON_URL=http://host.docker.internal:3000/api/slay-q\n       volumes  :\n         -   './slay-config-sample.json:/home/node/app/slay-config.json:ro'\n   volumes  :\n     slay_q_postgres  :\n  Run via Command Line  Run:     npx   slay-q-server   /path/to/slay-config.json\n  Run without installing:     npx   @slay-pics/slay-q-server@latest   /path/to/slay-config.json\n  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"}]},"mtime":1705307740141,"integrity":"kFhMunwCtR"}